# -*- coding: utf-8 -*-
"""FP_Regressor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17ZgqiHROc1C7DwX2tCUR5WfX8HX2g2Ch
"""

# --AEQUORIA FPS and OTHERS BELOW--
avGFP = 'MSKGEELFTGVVPILVELDGDVNGHKFSVSGEGEGDATYGKLTLKFICTTGKLPVPWPTLVTTFSYGVQCFSRYPDHMKQHDFFKSAMPEGYVQERTIFFKDDGNYKTRAEVKFEGDTLVNRIELKGIDFKEDGNILGHKLEYNYNSHNVYIMADKQKNGIKVNFKIRHNIEDGSVQLADHYQQNTPIGDGPVLLPDNHYLSTQSALSKDPNEKRDHMVLLEFVTAAGITHGMDELYK'
EGFP = 'MVSKGEELFTGVVPILVELDGDVNGHKFSVSGEGEGDATYGKLTLKFICTTGKLPVPWPTLVTTLTYGVQCFSRYPDHMKQHDFFKSAMPEGYVQERTIFFKDDGNYKTRAEVKFEGDTLVNRIELKGIDFKEDGNILGHKLEYNYNSHNVYIMADKQKNGIKVNFKIRHNIEDGSVQLADHYQQNTPIGDGPVLLPDNHYLSTQSALSKDPNEKRDHMVLLEFVTAAGITLGMDELYK'
greenlantern = 'MVSKGEELFTGVVPILVELDGDVNGHKFSVRGEGEGDATNGKLTLKFICTTGKLPVPWPTLVTTLGYGVACFARYPDHMKQHDFFKSAMPEGYVQERTISFKDDGTYKTRAEVKFEGDTLVNRIVLKGIDFKEDGNILGHKLEYNFNSHKVYITADKQKNGIKANFKTRHNVEDGGVQLADHYQQNTPIGDGPVLLPDNHYLSHQSKLSKDPNEKRDHMVLKERVTAAGITHDMDELYK'
mLemon = 'MSKGEELFTGVVPILVELDGDVNGHKFSVRGEGEGDATIGKLTLKFICTTGKLPVPWPTLVTSLGYGVQCFARYPDHMKQHDFFKSAMPEGYVQERTISFKDDGTYKTRAEVKFEGDTLVNRIELKGSGFKEDGNILGHKLEYNYNSHKVYITADKQKNGIKANFKIRHNVEDGSVQLADHYQQNTPIGDGPVLLPDNHYLSYQSKLSKDPNEKRDHMVLLEFLTAAGITHGMDELYK'
# ---DISCOSOMA RED FPS BELOW---
dsRed = 'MRSSKNVIKEFMRFKVRMEGTVNGHEFEIEGEGEGRPYEGHNTVKLKVTKGGPLPFAWDILSPQFQYGSKVYVKHPADIPDYKKLSFPEGFKWERVMNFEDGGVVTVTQDSSLQDGCFIYKVKFIGVNFPSDGPVMQKKTMGWEASTERLYPRDGVLKGEIHKALKLKDGGHYLVEFKSIYMAKKPVQLPGYYYVDSKLDITSHNEDYTIVEQYERTEGRHHLFL'
mHoneydew = 'MASSEDVIKEFMRFKVRMEGSVNGHEFEIEGEGEGRPYEGTQTAKLKVTKGGPLPFAWDILSPQFMWGSKAYVKHPADIPDYLKLSFPEGFKWERVMNFEDGGVVTVTQDSSLQDGEFIYKVKLRGTNFPSDGPVMQKKTMGWAATTERMYPEDGALKGEIKMRLKLKDGGHYDAEVKTTYMAKKPVQLPGAYKIDGKLDITSHNEDYTIVEQYERAEGRHSTGA'
lssmCherry = 'MVSKGEEDNMTIIKEFMRFKVHMEGSVNGHEFEIEGEGEGRPYEGTQTAKLKVTKGGPLPFAWDILSPQFMYGSKAYVKHPADIPDYLKLSFPEGFNWERVMNFEDGGVVTVTQDSSLQDGEFIYKVKLRGTNFPSDGPVMQCRTMGLEASTERMYPEDGALKGESKERLKLKDGGHYDAEVKTTYKAKKPVQLPGAYNVDIKLDILSHNEDYTIVEQYERSEGRHSTGGMDELYK'
mCherry = 'MVSKGEEDNMAIIKEFMRFKVHMEGSVNGHEFEIEGEGEGRPYEGTQTAKLKVTKGGPLPFAWDILSPQFMYGSKAYVKHPADIPDYLKLSFPEGFKWERVMNFEDGGVVTVTQDSSLQDGEFIYKVKLRGTNFPSDGPVMQKKTMGWEASSERMYPEDGALKGEIKQRLKLKDGGHYDAEVKTTYKAKKPVQLPGAYNVNIKLDITSHNEDYTIVEQYERAEGRHSTGGMDELYK'
mOrange = 'MVSKGEENNMAIIKEFMRFKVRMEGSVNGHEFEIEGEGEGRPYEGFQTAKLKVTKGGPLPFAWDILSPQFTYGSKAYVKHPADIPDYFKLSFPEGFKWERVMNFEDGGVVTVTQDSSLQDGEFIYKVKLRGTNFPSDGPVMQKKTMGWEASSERMYPEDGALKGEIKMRLKLKDGGHYTSEVKTTYKAKKPVQLPGAYIVGIKLDITSHNEDYTIVEQYERAEGRHSTGGMDELYK'
# --	ENTACMAEA QUADRICOLOR FPS BELOW --
eqFP578 = 'MSELIKENMHMKLYMEGTVNNHHFKCTSEGERKPYEGTQTMKIKVVEGGPLPFAFDILATSFMYGSKTFINHTQGIPDLFKQSFPEGFTWERITTYEDGGVLTATQDTSLQNGCIIYNVKINGVNFPSNGSVMQKKTLGWEANTEMLYPADGGLRGHSQMALKLVGGGYLHCSFKTTYRSKKPAKNLKMPGFHFVDHRLERIKEADKETYVEQHEMAVAKYCDLPSKLGHR'
mCardinal = 'MVSKGEELIKENMHMKLYMEGTVNNHHFKCTTEGEGKPYEGTQTQRIKVVEGGPLPFAFDILATCFMYGSKTFINHTQGIPDFFKQSFPEGFTWERVTTYEDGGVLTVTQDTSLQDGCLIYNVKLRGVNFPSNGPVMQKKTLGWEATTETLYPADGGLEGRCDMALKLVGGGHLHCNLKTTYRSKKPAKNLKMPGVYFVDRRLERIKEADNETYVEQHEVAVARYCDLPSKLGHKLNGMDELYK'
Katushka = 'MSVLITENMHMKLYMEGTVNDHHFKCTSEGEGKPYEGTQTMKIKVVEGGPLPFAFDILATSFMYGSKTFINHTQGIPDFFKQSFPEGFTWERITTYEDGGVLTATQDTSLQNGCLIYNVKINGVNFPSNGPVMQKKTLGWEASTEMLYPADSGLRGHSQMALKLVGGGYLHCSLKTTYRSKKPAKNLKMPGFYFVDRRLERIKEADKETYVEQHEMAVARYCDLPSKLGHS'
Electra1 = 'MVSKGEELIEENMRMKVVMEGSVNGHQFKCTGEGEGRPYEGVQTMRIKVIEGGPLPFAFDILATSFLFGSKTFIKYPADIPDFFKQSFPEGFTWERVTRYEDGGVVTVTQDTSLEDGGLVYNVKVRGVNFPSNGPVMQKKTEGWEPFTEMMYPANGGLRGYTDIALKVDGDGHLHANIVTTYRSKKTVGDIKMPGVHAVDYRLERVEESDNETYVVLREVAVAKYSNLGGGMDELYK'
#  --MISC FPS BELOW --
cpYGFP ='MTTFKIESRIHGNLNGEKFELVGGGVGEEGRLEIEMKTKDKPLAFSPFLLSHCMGYGFYHFASFPKGTKNIYLHAATNGGYTNTRKEIYEDGGILEVNFRYTYEFNKIIGDVECIGHGFPSQSPIFKDTIVKSCPTVDLMLPMSGNIIASSYARAFQLKDGSFYTAEVKNNIDFKNPIHESFSKSGPMFTHRRVEETHTKENLAMVEYQQVFNSAPRDM'
eYGFPuv = 'MTTFKIESRIHGNLNGEKFELVGGGVGEEGRLEIEMKTKDKPLAFSPFLLTTCMGYGFYHFASFPKGIKNIYLHAATNGGYTNTRKEIYEDGGILENFRYTYEFNKIIGDVECIGHGFPSQSPIFKDTIVKSCPTVDLMLPMSGNIIASSYAYAFQLKDGSFYTAEVKNNIDFKNPIHESFSKSGPMFTHRRVEETLTKENLAIVEYQQVFNSAPRDM'
mScarlet = 'MVSKGEAVIKEFMRFKVHMEGSMNGHEFEIEGEGEGRPYEGTQTAKLKVTKGGPLPFSWDILSPQFMYGSRAFTKHPADIPDYYKQSFPEGFKWERVMNFEDGGAVTVTQDTSLEDGTLIYKVKLRGTNFPPDGPVMQKKTMGWEASTERLYPEDGVLKGDIKMALRLKDGGRYLADFKTTYKAKKPVQMPGAYNVDRKLDITSHNEDYTVVEQYERSEGRHSTGGMDELYK'

# --End Sequences--





# THIS VAR WILL DETERMINE THE PARAMETER FOR INTERROGATION - CHANGE ACCORDINGLY (brightness, ex_max, em_max, stokes_shift)

var = 'brightness'
# -INPUT TEMPLATE BELOW-
template = mScarlet
template_name = 'mScarlet'
data_selection = 'All_Data'

import requests
import numpy as np
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score

from google.colab import drive
drive.mount('/content/drive')

"""KEEP CODE BLOCK BELOW - THIS IS THE ORIGINAL SCRIPT TO RETRIEVE DATAFRAME (CONTAINS CHANNELRHODPSIN)"""

# parent_organism=6100& #ADD TO GET AEQUORIA
# parent_organism=86600& #ADD TO GET Discosoma sp
# parent_organism=6118& #ADD TO GET 	Entacmaea quadricolor

proteins = []
url = "https://www.fpbase.org/api/proteins/?format=json"

while url:
    response = requests.get(url)
    response.raise_for_status()
    data = response.json()

    if isinstance(data, list):
        proteins.extend(data)
        break
    else:
        proteins.extend(data.get("results", []))
        url = data.get("next")

# Remove channelrhodopsins
proteins = [
    p for p in proteins
    if 'channelrhodopsin' not in (p.get('name') or '').lower()
]

# Compute Stokes shift
for protein in proteins:
    protein['stokes_shift'] = None

    for state in protein.get("states", []):
        ex_max = state.get("ex_max")
        em_max = state.get("em_max")

        if ex_max is not None and em_max is not None:
            shift = em_max - ex_max
            state["stokes_shift"] = shift
            protein["stokes_shift"] = shift
            break  # First valid state only

# Example check: print names and stokes shift
# for p in proteins:
#     print(f"{p.get('name')}: Stokes shift = {p.get('stokes_shift')}")

# Find proteins with suspicious Stokes shift
for p in proteins:
    shift = p.get('stokes_shift')
    if shift is not None and (shift < 0 or shift > 70):
        print(f"{p.get('name')}: ex_max = {p['states'][0].get('ex_max')}, em_max = {p['states'][0].get('em_max')}, Stokes shift = {shift}")

import random

# Your original sequence
template_mutate = "MVSKGEELFTGVVPILVELDGDVNGHKFSVSGEGEGDATYGKLTLKFICTTGKLPVPWPTLVTTLTYGVQCFSRYPDHMKQHDFFKSAMPEGYVQERTIFFKDDGNYKTRAEVKFEGDTLVNRIELKGIDFKEDGNILGHKLEYNYNSHNVYIMADKQKNGIKVNFKIRHNIEDGSVQLADHYQQNTPIGDGPVLLPDNHYLSTQSALSKDPNEKRDHMVLLEFVTAAGITLGMDELYK"

# Set the number of mutations
num_mutations = 1  # Adjust as needed

# Amino acid alphabet
amino_acids = list("ACDEFGHIKLMNPQRSTVWY")

# Convert to list for mutability
mutated = list(template_mutate)

# Get unique mutation positions
positions = sorted(random.sample(range(len(template_mutate)), num_mutations))

# Track mutation descriptions
mutation_descriptions = []

for pos in positions:
    original_aa = mutated[pos]
    choices = [aa for aa in amino_acids if aa != original_aa]
    new_aa = random.choice(choices)
    mutated[pos] = new_aa
    mutation_descriptions.append(f"{original_aa}{pos + 1}{new_aa}")  # 1-based indexing

# Join back to string
mutated_sequence = ''.join(mutated)

# Output
print("Original sequence:")
print(template_mutate)
print("\nMutated sequence:")
print(mutated_sequence)
print(f"\nMutations ({num_mutations}): {', '.join(mutation_descriptions)}")









print(f"Total protein records retrieved: {len(proteins)}")

# Step 2: Extract sequences and brightness
seqs, brightness_vals = [], []

for entry in proteins:
    seq = entry.get("seq")
    states = entry.get("states", [])
    brightness = None
    if states and isinstance(states, list):
        brightness = states[0].get(var)

    if seq and brightness is not None:
        seqs.append(seq)
        brightness_vals.append(brightness)

print(f"Total usable sequences: {len(seqs)}")

# Step 3: One-hot encode sequences
max_len = 238  # EGFP is 238 aa long
aa_alphabet = 'ACDEFGHIKLMNPQRSTVWY'
aa_index = {aa: i for i, aa in enumerate(aa_alphabet)}

def one_hot_encode(seq, max_len):
    arr = np.zeros((max_len, len(aa_alphabet)), dtype=np.float32)
    for i, aa in enumerate(seq[:max_len]):
        if aa in aa_index:
            arr[i, aa_index[aa]] = 1.0
    return arr.flatten()

X = np.array([one_hot_encode(seq, max_len) for seq in seqs])
y = np.array(brightness_vals)

# Step 4: Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)

# Step 5: Train Random Forest
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# Step 6: Evaluation
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Random Forest")
print(f"  MAE: {mae:.2f}")
print(f"  RÂ² Score: {r2:.2f}")

# Step 7: Plot predicted vs actual
plt.figure(figsize=(6, 6))
plt.scatter(y_test, y_pred, color='red', alpha=0.7, label='Test Data')
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='blue', label='Ideal Fit')

# Step 8: Multiple validation sequences
validation_data = [
    {
        "seq": "MVSKGEELFAGIVPVLIELDGDVHGHKFSVRGEGEGDADYGKLEIKFICTTGKLPVPWPTLVTTLTYGVQCFARYPKHMKMNDFFKSAMPEGYIQERTILFQDDGKYKTRGEVKFEGDTLVNRIELKGKDFKEDGNILGHKLEYSFNSHNVYITPDKANNGLEVNFKTRHNIEGGGVQLADHYQTNVPLGDGPVLIPINHYLSYQTDISKDRNEARDHMVLLESVSACSHTHGMDELYR",
        "true_brightness": 31.64
    },
    {
        "seq": "MSGGEELFAGIVPVLIELDGDVHGHKFSVRGEGEGDADYGKLEIKFICTTGKLPVPWPTLVTTLAWGIQCFARYPEHMKMNDFFKSAMPEGYIQERTIHFQDDGKYKTRGEVKFEGDTLVNRVELKGEGFKEDGNILGHKLEYSAISDNVYIMPDKANNGLEANFKIRHNIEGGGVQLADHYQTNVPLGDGPVLIPINHYLSCQSAISKDRNEARDHMVLLESFSAYCHTHGMDELYR",
        "true_brightness": 21.09
    },
    {
        "seq": "MSKGAELFTGIVPILIELNGDVNGHKFSVSGEGEGDATYGKLTLKFICTTGKLPVPWPTLVATLSYGVQCFSRYPDHMKQHDFFKSAMPEGYIQERTIFFEDDGNYKTRAEVKFEGDTLVSRIELTGTDFKEDGNILGNKMEYNYNATNVYIVADKARNGIKVNFKVRHNIKDGSVQLADHYQQNTPIGDGPVLLPDNHYLSTQSALSKDPNEKRDHMIYLEFVTAAAITHGMDELYK",
        "true_brightness": 10.2
    },
    {
        "seq": "MSKGAELFTGIVPILIELNGDVNGHKFSVSGEGEGDATYGKLTLKFICTTGKLPVPWPTLVATLSYGVQCFSRYPDHMKQHDFFKSAMPEGYIQERTIFFEDDGNYKSRAEVKFEGDTLVSRIELTGTDFKEDGNILGNKMEYNYNATNVYIMTDKARNGIKVNFKVRHNIKDGSVQLADHYQQNTPIGDGPVLLPDNHYLSTQSALSKDPNEKRDHMIYLEFVTAAAITHGMDELYKWKLN",
        "true_brightness": 5
    },
    {
        "seq": "MNVMRYNRGFCRVLQNGVKNLRSRNCSTEEKPVILGAMTETFQKKLPYKLELDGDVDGQTFKVIGEGVGDATTGVIEGKYVCTEGEVPISWVSLITSLSYGAKCFVRYPNEINDFFKSTFPSGYHQERKITYENDGVLETAAKITMESGAIVNRINVKGTGFDKDGHVCQKNLESSPPSTTYVVPEGEGIRIIYRNIYPTKDGHYVVADTQQVNRPIRAQGTSAIPTYHHIKSKVDLSTDPEENKDHIIIKETNCAFDADFS",
        "true_brightness": 48,
        # repeat for consistency
    },
    {
        #RANDOM SEQUENCE FROM TEMPLATE IS SHOWN BELOW
        "seq": mutated_sequence,
        "true_brightness":60.5,
        # repeat for consistency
    }
]

for i, vdata in enumerate(validation_data, 1):
    encoded = one_hot_encode(vdata["seq"], max_len).reshape(1, -1)
    pred = model.predict(encoded)[0]
    print(f"Validation {i}: True = {vdata['true_brightness']:.2f}, Predicted = {pred:.2f}")

    point_color = 'blue' if i == 6 else 'yellow'
    annotation = 'Randomized\nSeq' if i == 6 else f'V-{i}'

    plt.plot([vdata["true_brightness"], vdata["true_brightness"]],[vdata["true_brightness"], pred], 'k--', alpha=0.4)
    plt.scatter([vdata["true_brightness"]], [pred],color=point_color, edgecolor='k', s=120, label=f'Validation Data' if i == 1 else None)
    plt.text(vdata["true_brightness"]+7, pred, annotation, fontsize=9, ha='right', va='bottom')

plt.xlabel(f'Actual {var.title()}')
plt.ylabel(f'Predicted {var.title()}')
plt.title(f'Random Forest: Predicted vs Actual {var.title()}')
plt.legend()
plt.grid(False)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Assume X, y, proteins, etc. are already defined as in your script

# Split and train
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=None)
model = RandomForestRegressor(n_estimators=100, random_state=None)
model.fit(X_train, y_train)

# Predictions
y_pred_test = model.predict(X_test)
y_pred_train = model.predict(X_train)

r2_train = r2_score(y_train, y_pred_train)
r2_test = r2_score(y_test, y_pred_test)

print(f"Random Forest Performance:")
print(f"  RÂ² (Train): {r2_train:.3f}")
print(f"  RÂ² (Test): {r2_test:.3f}")

# Plot
plt.figure(figsize=(6, 6))

# Plot training data
plt.scatter(y_train, y_pred_train, color='black', alpha=0.5, label=f'Train Data{r2_train:.2f}')

# Plot test data
plt.scatter(y_test, y_pred_test, color='red', alpha=0.7, label=f'Test Data{r2_test:.2f}')

# Ideal fit line
all_y = np.concatenate([y_train, y_test])
plt.plot([min(all_y), max(all_y)], [min(all_y), max(all_y)], color='blue', label='Ideal Fit')

# Validation data
for i, vdata in enumerate(validation_data, 1):
    encoded = one_hot_encode(vdata["seq"], max_len).reshape(1, -1)
    pred = model.predict(encoded)[0]

    point_color = 'blue' if i == 6 else 'yellow'
    annotation = 'Randomized\nSeq' if i == 6 else f'V-{i}'

    # plt.plot([vdata["true_brightness"], vdata["true_brightness"]], [vdata["true_brightness"], pred], 'k--', alpha=0.4)
    # plt.scatter([vdata["true_brightness"]], [pred],
    #             color=point_color, edgecolor='k', s=120,
    #             label='Validation Data' if i == 1 else None)
    # plt.text(vdata["true_brightness"] + 7, pred, annotation, fontsize=9, ha='right', va='bottom')

# Labels and styling
plt.xlabel(f'Actual {var.title()}')
plt.ylabel(f'Predicted {var.title()}')
plt.title(f'Random Forest: Predicted vs Actual {var.title()}')
plt.legend()
plt.grid(False)
plt.tight_layout()
plt.show()







"""# ðŸš€ðŸ’¡ **INTERROGATE IMPACT OF MUTATIONS** ðŸ”¬âœ¨

"""

import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score
import random

# Load & prepare the dataset
seqs, brightness_vals = [], []

for entry in proteins:
    seq = entry.get("seq")
    states = entry.get("states", [])
    brightness = None
    if states and isinstance(states, list):
        brightness = states[0].get(var)

    if seq and brightness is not None:
        seqs.append(seq)
        brightness_vals.append(brightness)

print(f"Total usable sequences: {len(seqs)}")

# Define amino acid properties
max_len = 238
aa_alphabet = 'ACDEFGHIKLMNPQRSTVWY'
aa_index = {aa: i for i, aa in enumerate(aa_alphabet)}

def one_hot_encode(seq, max_len):
    arr = np.zeros((max_len, len(aa_alphabet)), dtype=np.float32)
    for i, aa in enumerate(seq[:max_len]):
        if aa in aa_index:
            arr[i, aa_index[aa]] = 1.0
    return arr.flatten()

# Encode input sequences
X = np.array([one_hot_encode(seq, max_len) for seq in seqs])
y = np.array(brightness_vals)

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=None)

# Train Random Forest
model = RandomForestRegressor(n_estimators=100, random_state=None)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# Evaluate
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Random Forest")
print(f"  MAE: {mae:.2f}")
print(f"  RÂ² Score: {r2:.2f}")

# --- Mutation Prediction Phase ---



mutant_predictions = {}

for pos in range(len(template)):
    original_aa = template[pos]
    for new_aa in aa_alphabet:
        if new_aa != original_aa:
            mutated = list(template)
            mutated[pos] = new_aa
            mutated_seq = ''.join(mutated)
            encoded = one_hot_encode(mutated_seq, max_len).reshape(1, -1)
            pred_brightness = model.predict(encoded)[0]
            mutation_label = f"{original_aa}{pos + 1}{new_aa}"
            mutant_predictions[mutation_label] = pred_brightness
            print(f"{mutation_label}: Predicted {var.title()} = {pred_brightness:.2f}")

import numpy as np

# Sort data
sorted_items = sorted(mutant_predictions.items(), key=lambda x: x[1], reverse=True)
mutations, predictions = zip(*sorted_items)
predictions = np.array(predictions)

# Compute mean and std
mean_brightness = predictions.mean()
std_brightness = predictions.std()

# Set N standard deviations
N = 2
upper_threshold = mean_brightness + N * std_brightness
lower_threshold = mean_brightness - N * std_brightness

# Generate random x positions for jitter
x_jitter = np.random.uniform(-0.2, 0.2, size=len(predictions))
x_positions = 0 + x_jitter
# x_positions = np.arange(len(predictions))

# Plot
plt.figure(figsize=(12, 6), facecolor='w')
ax = plt.gca()
ax.set_facecolor('w')
plt.scatter(x_positions, predictions, color='black', s=20, alpha=0.7)

# # Annotate outliers
for xi, yi, label in zip(x_positions, predictions, mutations):
    if yi > upper_threshold or yi < lower_threshold:
        plt.annotate(
            label,
            (xi, yi),
            textcoords="offset points",
            xytext=(3, 3),
            ha='left',
            fontsize=7,
            color='red' if yi > upper_threshold else 'blue'
        )

# Draw mean and thresholds
plt.axhline(mean_brightness, color='green', linestyle='--', alpha=0.7, label=f'Mean = {mean_brightness:.2f}')
plt.axhline(upper_threshold, color='red', linestyle=':', alpha=0.7, label=f'+{N}Ïƒ = {upper_threshold:.2f}')
plt.axhline(lower_threshold, color='blue', linestyle=':', alpha=0.7, label=f'-{N}Ïƒ = {lower_threshold:.2f}')
plt.legend()

# Labels
plt.ylabel(f'Predicted {var.title()}')
plt.title(f'Predicted {var.title()} of Single Point Mutants (Outliers: Â±{N} SD)')
plt.grid(False)

plt.tight_layout()
plt.show()

position = 69  # 1-based position
aa = template[position - 1]  # convert to 0-based index
print(f"Amino acid at position {position} is {aa}")

mutation = "V69M"

if mutation in mutant_predictions:
    print(f"{mutation}: Predicted {var.title()} = {mutant_predictions[mutation]:.4f}")
else:
    print(f"{mutation} not found in mutant_predictions.")

# Assuming sorted_items is a list of (mutation, brightness) sorted in ascending order
highest = sorted_items[:20]
lowest = sorted_items[-20:]

# Print header
print(f"{'Lowest Mutations':<20} {var.title():<10} | {'Highest Mutations':<20} {var.title()}")
print("-" * 65)

# Print paired rows
for low, high in zip(lowest, highest):
    low_mut, low_val = low
    high_mut, high_val = high
    print(f"{low_mut:<20} {low_val:<10.2f} | {high_mut:<20} {high_val:.2f}")



"""# ===============================
# ðŸ¤–ðŸ¤–  GREEDY SEARCH-BASED EVOLUTION ðŸ¤– ðŸ¤–
# ===============================
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score


for i in range (20+1):
# [[ADJUST THRESHOLD VALUE BELOW]]
  threshold = 2


# Load & prepare the dataset
seqs, vals = [], []
for entry in proteins:
    seq = entry.get("seq")
    states = entry.get("states", [])
    val = None
    if states and isinstance(states, list):
        val = states[0].get(var)
    if seq and val is not None:
        seqs.append(seq)
        vals.append(val)

print(f"Total usable sequences: {len(seqs)}")

# One-hot encoding setup
max_len = 238
aa_alphabet = 'ACDEFGHIKLMNPQRSTVWY'
aa_index = {aa: i for i, aa in enumerate(aa_alphabet)}

def one_hot_encode(seq, max_len):
    arr = np.zeros((max_len, len(aa_alphabet)), dtype=np.float32)
    for i, aa in enumerate(seq[:max_len]):
        if aa in aa_index:
            arr[i, aa_index[aa]] = 1.0
    return arr.flatten()

# Train model
X = np.array([one_hot_encode(seq, max_len) for seq in seqs])
y = np.array(vals)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=None)

model = RandomForestRegressor(n_estimators=100, random_state=None)
model.fit(X_train, y_train)

mae = mean_absolute_error(y_test, model.predict(X_test))
r2 = r2_score(y_test, model.predict(X_test))
print(f"Random Forest: MAE = {mae:.2f}, RÂ² = {r2:.2f}")

# --- Directed evolution ---

current_seq = template
mutations_applied = []
property_history = []
all_mutation_log = []

encoded = one_hot_encode(current_seq, max_len).reshape(1, -1)
current_pred = model.predict(encoded)[0]
print(f"Starting {var.title()}: {current_pred:.2f}")
property_history.append(('Template', current_pred))

step_counter = 0

for pos in range(len(current_seq)):
    original_aa = current_seq[pos]
    best_pred = current_pred
    best_mutation = None
    best_seq = current_seq

    for new_aa in aa_alphabet:
        if new_aa != original_aa:
            seq_list = list(current_seq)
            seq_list[pos] = new_aa
            mutated_seq = ''.join(seq_list)

            encoded = one_hot_encode(mutated_seq, max_len).reshape(1, -1)
            pred = model.predict(encoded)[0]

            # Log the mutation + what step it's at
            all_mutation_log.append({
                'mutation': f"{original_aa}{pos + 1}{new_aa}",
                'predicted': pred,
                'accepted': False,
                'step': step_counter
            })

            if pred > best_pred+threshold:
                best_pred = pred
                best_mutation = f"{original_aa}{pos + 1}{new_aa}"
                best_seq = mutated_seq

    if best_pred > current_pred+threshold:
        current_pred = best_pred
        current_seq = best_seq
        mutations_applied.append(best_mutation)
        property_history.append((best_mutation, current_pred))
        step_counter += 1

        # Update accepted flag
        for log in all_mutation_log:
            if log['mutation'] == best_mutation and log['predicted'] == best_pred and log['step'] == step_counter - 1:
                log['accepted'] = True
                log['step'] = step_counter  # accepted mutation step
                break
        print(f"Applied {best_mutation}: {var.title()} = {current_pred:.2f}")
    else:
        step_counter += 1


print(f'Evolved Sequence = {current_seq}')
print()
print(f'All mutations from Greedy Search for {var.title()} = {mutations_applied}')

# Build the FASTA header
fasta_header = f">Evolved_{var.title()}_threshold:{threshold}_{template_name}"

# Wrap the sequence to 60 characters per line (FASTA style)
fasta_sequence = '\n'.join([current_seq[i:i+60] for i in range(0, len(current_seq), 60)])

# Compose FASTA content
fasta_content = f"{fasta_header}\n{fasta_sequence}\n"

# Define file path
fasta_path = "/content/drive/MyDrive/Machine_Learning_FP_Evolution/avGFP_Evolved_Sequences_From_ML.fasta"

# Append to the file
with open(fasta_path, 'a') as f:
    f.write(fasta_content)

print(f"Appended evolved sequence to: {fasta_path}")



# --- Plotting ---
labels, values = zip(*property_history)
helpful_x = list(range(len(values)))
helpful_y = values

unhelpful_x = [log['step'] for log in all_mutation_log if not log['accepted']]
unhelpful_y = [log['predicted'] for log in all_mutation_log if not log['accepted']]

plt.figure(figsize=(6, 6))
plt.scatter(helpful_x, helpful_y, color='cornflowerblue',alpha=0.8, s=50, marker='^', label='Accepted mutations')
plt.scatter(unhelpful_x, unhelpful_y, color='orange', alpha=0.3, s=10, label='Unhelpful mutations')

plt.xlabel('Mutation step')
plt.ylabel(f'Predicted {var.title()}')
plt.title(f"In-Silico Directed Evolution of {var.title()}")
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Extract from property_history
original_pred = property_history[0][1]
final_pred = property_history[-1][1]

labels = ['Template', 'Final Evolved']
values = [original_pred, final_pred]

# Plot
plt.figure(figsize=(4, 4))
bars = plt.bar(labels, values, color=['gray', 'skyblue'], edgecolor='black')

# Annotate bars
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width() / 2, height + 0.5,
             f"{height:.2f}", ha='center', va='bottom', fontsize=10)

# Style
plt.ylabel(f'Predicted {var.title()}')
plt.title(f'Predicted {var.title()} Comparison From Greedy Search')
plt.ylim(0, max(values) * 1.2)
plt.axhline(0, linewidth=2, color='k')

for spine in plt.gca().spines.values():
    spine.set_visible(False)

plt.tight_layout()
plt.show()



"""#ðŸš€ðŸš€ Predict Protein Properties ðŸš€ðŸš€
=============================================================================
"""



import re

# Your existing functions
max_len = 238
aa_alphabet = 'ACDEFGHIKLMNPQRSTVWY'
aa_index = {aa: i for i, aa in enumerate(aa_alphabet)}

def one_hot_encode(seq, max_len):
    arr = np.zeros((max_len, len(aa_alphabet)), dtype=np.float32)
    for i, aa in enumerate(seq[:max_len]):
        if aa in aa_index:
            arr[i, aa_index[aa]] = 1.0
    return arr.flatten()

def parse_mutation(mutation_str):
    match = re.match(r"([A-Z])(\d+)([A-Z])", mutation_str)
    if not match:
        raise ValueError(f"Invalid mutation format: {mutation_str}")
    orig_aa, pos, new_aa = match.groups()
    return int(pos), new_aa

def apply_mutations(seq, mutations):
    seq_list = list(seq)
    for pos, new_aa in mutations:
        if 1 <= pos <= len(seq_list):
            seq_list[pos - 1] = new_aa
        else:
            print(f"Warning: position {pos} is out of range.")
    return ''.join(seq_list)

# MAIN LOOP
vars = ['ex_max', 'em_max', 'stokes_shift', 'brightness']
n_runs = 10

for var in vars:
    template_seq = template
    parsed_mutations = [parse_mutation(m) for m in mutations_applied]

    template_preds = []
    mutant_preds = []

    for i in range(n_runs):
        # Load dataset
        seqs, vals = [], []
        for entry in proteins:
            seq = entry.get("seq")
            states = entry.get("states", [])
            val = None
            if states and isinstance(states, list):
                val = states[0].get(var)
            if seq and val is not None:
                seqs.append(seq)
                vals.append(val)


        X = np.array([one_hot_encode(seq, max_len) for seq in seqs])
        y = np.array(vals)

        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

        model = RandomForestRegressor(n_estimators=100)
        model.fit(X_train, y_train)

        # Evaluate
        mae = mean_absolute_error(y_test, model.predict(X_test))
        r2 = r2_score(y_test, model.predict(X_test))
        print(f"Run {i+1} {var}: MAE = {mae:.2f}, RÂ² = {r2:.2f}")

        # Predict template + mutant
        template_encoded = one_hot_encode(template_seq, max_len).reshape(1, -1)
        mutant_seq = apply_mutations(template_seq, parsed_mutations)
        mutant_encoded = one_hot_encode(mutant_seq, max_len).reshape(1, -1)

        template_pred = model.predict(template_encoded)[0]
        mutant_pred = model.predict(mutant_encoded)[0]

        template_preds.append(template_pred)
        mutant_preds.append(mutant_pred)

    # Plot
    labels = ['Template', 'Mutated']
    means = [np.mean(template_preds), np.mean(mutant_preds)]
    all_preds = [template_preds, mutant_preds]

    plt.figure(figsize=(5, 5))
    bars = plt.bar(labels, means, color=['gray', 'skyblue'], edgecolor='black')

    # Annotate mean
    for bar in bars:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width() / 2, height *1.03,
                 f"{height:.2f}", ha='center', va='bottom', zorder = 4)

    # Overlay individual run points
    for i, preds in enumerate(all_preds):
        x = np.full(len(preds), i) + np.random.uniform(-0.1, 0.1, size=len(preds))  # jitter
        plt.scatter(x, preds, color='k', zorder=3, edgecolor = 'k', s=4)

    plt.ylabel(f'Predicted {var.title()}')
    plt.title(f'Predicted {var.title()} Across {n_runs} Runs for Evolved {template_name}')
    plt.ylim(0, max(means + [max(p) for p in all_preds]) * 1.2)
    plt.axhline(0, color='k', linewidth=2)
    for spine in plt.gca().spines.values():
        spine.set_visible(False)

    plt.tight_layout()
    plt.show()
    print(f"Total usable sequences: {len(seqs)}")
    print(f'Applied Mutations: {mutations_applied}')





"""# ===============================
# ðŸŒŸðŸŒŸ  GREEDY SEARCH BASED EVOLUTION ðŸŒŸðŸŒŸ
  ðŸŒŸðŸŒŸREVERSE DIRECTIONðŸŒŸðŸŒŸ
# ===============================
"""

# raise RuntimeError("Intentionally stopping notebook execution at this cell.")

# Assuming proteins, var, etc. are already defined
var = 'ex_max'

#--INPUT TEMPLATE SEQUENCE BELOW--
template = current_seq

#[[UPDATE THRESHOLD BELOW]]
threshold = 1


# Load & prepare the dataset
seqs, vals = [], []
for entry in proteins:
    seq = entry.get("seq")
    states = entry.get("states", [])
    val = None
    if states and isinstance(states, list):
        val = states[0].get(var)
    if seq and val is not None:
        seqs.append(seq)
        vals.append(val)

print(f"Total usable sequences: {len(seqs)}")

# One-hot encoding setup
max_len = 238
aa_alphabet = 'ACDEFGHIKLMNPQRSTVWY'
aa_index = {aa: i for i, aa in enumerate(aa_alphabet)}

def one_hot_encode(seq, max_len):
    arr = np.zeros((max_len, len(aa_alphabet)), dtype=np.float32)
    for i, aa in enumerate(seq[:max_len]):
        if aa in aa_index:
            arr[i, aa_index[aa]] = 1.0
    return arr.flatten()

# Train model
X = np.array([one_hot_encode(seq, max_len) for seq in seqs])
y = np.array(vals)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=None)

model = RandomForestRegressor(n_estimators=100, random_state=None)
model.fit(X_train, y_train)

mae = mean_absolute_error(y_test, model.predict(X_test))
r2_test = r2_score(y_test, model.predict(X_test))
r2_train = r2_score(y_train, model.predict(X_train))
print(f"Random Forest: MAE = {mae:.2f}, RÂ² Test = {r2:.2f}, RÂ² Train = {r2_train}" )

# --- Directed evolution ---

current_seq = template
mutations_applied = []
property_history = []
all_mutation_log = []

encoded = one_hot_encode(current_seq, max_len).reshape(1, -1)
current_pred = model.predict(encoded)[0]
print(f"Starting {var.title()}: {current_pred:.2f}")
property_history.append(('Template', current_pred))

step_counter = 0

for pos in range(len(current_seq)):
    original_aa = current_seq[pos]
    best_pred = current_pred
    best_mutation = None
    best_seq = current_seq

    for new_aa in aa_alphabet:
        if new_aa != original_aa:
            seq_list = list(current_seq)
            seq_list[pos] = new_aa
            mutated_seq = ''.join(seq_list)

            encoded = one_hot_encode(mutated_seq, max_len).reshape(1, -1)
            pred = model.predict(encoded)[0]

            # Log the mutation + what step it's at
            all_mutation_log.append({
                'mutation': f"{original_aa}{pos + 1}{new_aa}",
                'predicted': pred,
                'accepted': False,
                'step': step_counter
            })

            if pred < best_pred-threshold:
                best_pred = pred
                best_mutation = f"{original_aa}{pos + 1}{new_aa}"
                best_seq = mutated_seq

    if best_pred < current_pred-threshold:
        current_pred = best_pred
        current_seq = best_seq
        mutations_applied.append(best_mutation)
        property_history.append((best_mutation, current_pred))
        step_counter += 1

        # Update accepted flag
        for log in all_mutation_log:
            if log['mutation'] == best_mutation and log['predicted'] == best_pred and log['step'] == step_counter - 1:
                log['accepted'] = True
                log['step'] = step_counter  # accepted mutation step
                break
        print(f"Applied {best_mutation}: {var.title()} = {current_pred:.2f}")
    else:
        step_counter += 1


print(f'Evolved Sequence = {current_seq}')
print(f'All mutations from Greedy Search for {var.title()} = {mutations_applied}')

# --- Plotting ---
labels, values = zip(*property_history)
helpful_x = list(range(len(values)))
helpful_y = values

unhelpful_x = [log['step'] for log in all_mutation_log if not log['accepted']]
unhelpful_y = [log['predicted'] for log in all_mutation_log if not log['accepted']]

plt.figure(figsize=(6, 6))
plt.scatter(helpful_x, helpful_y, color='cornflowerblue',alpha=0.5, s=10, label='Accepted mutations')
plt.scatter(unhelpful_x, unhelpful_y, color='orange', alpha=0.3, s=10, label='Unhelpful mutations')

plt.xlabel('Mutation step')
plt.ylabel(f'Predicted {var.title()}')
plt.title(f"In-Silico Directed Evolution of {var.title()}")
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Extract from property_history
original_pred = property_history[0][1]
final_pred = property_history[-1][1]

labels = ['Template', 'Final Evolved']
values = [original_pred, final_pred]

# Plot
plt.figure(figsize=(4, 4))
bars = plt.bar(labels, values, color=['gray', 'skyblue'], edgecolor='black')

# Annotate bars
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width() / 2, height + 0.5,
             f"{height:.2f}", ha='center', va='bottom', fontsize=10)

# Style
plt.ylabel(f'Predicted {var.title()}')
plt.title(f'Predicted {var.title()} Comparison From Greedy Search')
plt.ylim(0, max(values) * 1.2)
plt.axhline(0, linewidth=2, color='k')

for spine in plt.gca().spines.values():
    spine.set_visible(False)

plt.tight_layout()
plt.show()
print(f'All mutations from Greedy Search = {mutations_applied}')







"""#ðŸ¥³ðŸ¥³ðŸ¥³Generate Many Evolved Sequences for Desired Property ðŸ¥³ðŸ¥³ðŸ¥³"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score

vars = ['ex_max', 'em_max', 'stokes_shift', 'brightness' ]


input("To Generate Multiple Sequences press Enter to continue...")

for var in vars:
  print(f'>>Evolving {template_name} using {var.title()} as a parameter<<')

  for i in range (30):

    # [[ADJUST THRESHOLD VALUE BELOW]]
    threshold = 3


    # Load & prepare the dataset
    seqs, vals = [], []
    for entry in proteins:
        seq = entry.get("seq")
        states = entry.get("states", [])
        val = None
        if states and isinstance(states, list):
            val = states[0].get(var)
        if seq and val is not None:
            seqs.append(seq)
            vals.append(val)

    print(f"Total usable sequences: {len(seqs)}")

    # One-hot encoding setup
    max_len = 238
    aa_alphabet = 'ACDEFGHIKLMNPQRSTVWY'
    aa_index = {aa: i for i, aa in enumerate(aa_alphabet)}

    def one_hot_encode(seq, max_len):
        arr = np.zeros((max_len, len(aa_alphabet)), dtype=np.float32)
        for i, aa in enumerate(seq[:max_len]):
            if aa in aa_index:
                arr[i, aa_index[aa]] = 1.0
        return arr.flatten()

    # Train model
    X = np.array([one_hot_encode(seq, max_len) for seq in seqs])
    y = np.array(vals)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=None)

    model = RandomForestRegressor(n_estimators=100, random_state=None)
    model.fit(X_train, y_train)

    mae = mean_absolute_error(y_test, model.predict(X_test))
    r2 = r2_score(y_test, model.predict(X_test))
    print(f"Random Forest: MAE = {mae:.2f}, RÂ² = {r2:.2f}")

    # --- Directed evolution ---

    current_seq = template
    mutations_applied = []
    property_history = []
    all_mutation_log = []

    encoded = one_hot_encode(current_seq, max_len).reshape(1, -1)
    current_pred = model.predict(encoded)[0]
    print(f"Starting {var.title()}: {current_pred:.2f}")
    property_history.append(('Template', current_pred))

    step_counter = 0

    for pos in range(len(current_seq)):
        original_aa = current_seq[pos]
        best_pred = current_pred
        best_mutation = None
        best_seq = current_seq

        for new_aa in aa_alphabet:
            if new_aa != original_aa:
                seq_list = list(current_seq)
                seq_list[pos] = new_aa
                mutated_seq = ''.join(seq_list)

                encoded = one_hot_encode(mutated_seq, max_len).reshape(1, -1)
                pred = model.predict(encoded)[0]

                # Log the mutation + what step it's at
                all_mutation_log.append({
                    'mutation': f"{original_aa}{pos + 1}{new_aa}",
                    'predicted': pred,
                    'accepted': False,
                    'step': step_counter
                })

                if pred > best_pred+threshold:
                    best_pred = pred
                    best_mutation = f"{original_aa}{pos + 1}{new_aa}"
                    best_seq = mutated_seq

        if best_pred > current_pred+threshold:
            current_pred = best_pred
            current_seq = best_seq
            mutations_applied.append(best_mutation)
            property_history.append((best_mutation, current_pred))
            step_counter += 1

            # Update accepted flag
            for log in all_mutation_log:
                if log['mutation'] == best_mutation and log['predicted'] == best_pred and log['step'] == step_counter - 1:
                    log['accepted'] = True
                    log['step'] = step_counter  # accepted mutation step
                    break
            print(f"Applied {best_mutation}: {var.title()} = {current_pred:.2f}")
        else:
            step_counter += 1


    print(f'Evolved {template_name} Sequence = {current_seq}')
    print(f'All mutations from Greedy Search for {var.title()} = {mutations_applied}')

    # Build the FASTA header
    fasta_header = f">Evolved_{var.title()}_threshold:{threshold}_{template_name}_{data_selection}_loop_{i+1}"

    # Wrap the sequence to 60 characters per line (FASTA style)
    fasta_sequence = '\n'.join([current_seq[i:i+60] for i in range(0, len(current_seq), 60)])

    # Compose FASTA content
    fasta_content = f"{fasta_header}\n{fasta_sequence}\n"

    # Define file path
    fasta_path = f"/content/drive/MyDrive/Machine_Learning_FP_Evolution/{template_name}_{var.title()}_Evolved_Sequences_From_ML.fasta"

    # Append to the file
    with open(fasta_path, 'a') as f:
        f.write(fasta_content)

    print(f"Appended evolved sequence to: {fasta_path}")
    print()
    print(f'\033[93mCompleted Loop {i+1}\033[0m')
    print()




print(f'REVERSE EVOLUTION PROCEEDING OF EX_MAX USING {template_name} AS THE TEMPLATE ')

# Assuming proteins, template_name, and template are already defined
var = 'ex_max'
threshold = 3
max_len = 238
aa_alphabet = 'ACDEFGHIKLMNPQRSTVWY'
aa_index = {aa: i for i, aa in enumerate(aa_alphabet)}

def one_hot_encode(seq, max_len):
    arr = np.zeros((max_len, len(aa_alphabet)), dtype=np.float32)
    for i, aa in enumerate(seq[:max_len]):
        if aa in aa_index:
            arr[i, aa_index[aa]] = 1.0
    return arr.flatten()

for i in range(30):
    # Load & prepare dataset
    seqs, vals = [], []
    for entry in proteins:
        seq = entry.get("seq")
        states = entry.get("states", [])
        val = None
        if states and isinstance(states, list):
            val = states[0].get(var)
        if seq and val is not None:
            seqs.append(seq)
            vals.append(val)

    print(f"Total usable sequences: {len(seqs)}")

    # Train model
    X = np.array([one_hot_encode(seq, max_len) for seq in seqs])
    y = np.array(vals)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=None)

    model = RandomForestRegressor(n_estimators=100, random_state=None)
    model.fit(X_train, y_train)

    mae = mean_absolute_error(y_test, model.predict(X_test))
    r2_test = r2_score(y_test, model.predict(X_test))
    r2_train = r2_score(y_train, model.predict(X_train))
    print(f"Random Forest: MAE = {mae:.2f}, RÂ² Test = {r2_test:.2f}, RÂ² Train = {r2_train:.2f}")

    # Directed evolution to minimize ex_max
    current_seq = template
    mutations_applied = []
    all_mutation_log = []

    encoded = one_hot_encode(current_seq, max_len).reshape(1, -1)
    current_pred = model.predict(encoded)[0]
    print(f"Starting {var.title()}: {current_pred:.2f}")

    step_counter = 0

    for pos in range(len(current_seq)):
        original_aa = current_seq[pos]
        best_pred = current_pred
        best_mutation = None
        best_seq = current_seq

        for new_aa in aa_alphabet:
            if new_aa != original_aa:
                seq_list = list(current_seq)
                seq_list[pos] = new_aa
                mutated_seq = ''.join(seq_list)

                encoded = one_hot_encode(mutated_seq, max_len).reshape(1, -1)
                pred = model.predict(encoded)[0]

                all_mutation_log.append({
                    'mutation': f"{original_aa}{pos + 1}{new_aa}",
                    'predicted': pred,
                    'accepted': False,
                    'step': step_counter
                })

                if pred < best_pred - threshold:
                    best_pred = pred
                    best_mutation = f"{original_aa}{pos + 1}{new_aa}"
                    best_seq = mutated_seq

        if best_pred < current_pred - threshold:
            current_pred = best_pred
            current_seq = best_seq
            mutations_applied.append(best_mutation)
            step_counter += 1

            for log in all_mutation_log:
                if log['mutation'] == best_mutation and log['predicted'] == best_pred and log['step'] == step_counter - 1:
                    log['accepted'] = True
                    log['step'] = step_counter
                    break

            print(f"Applied {best_mutation}: {var.title()} = {current_pred:.2f}")
        else:
            step_counter += 1

    print(f"Reverse Evolved {template_name} Sequence = {current_seq}")
    print(f"All mutations from Greedy Search for {var.title()} = {mutations_applied}")

    # FASTA output
    fasta_header = f">Reverse_Evolved_{var.title()}_threshold:{threshold}_{template_name}_{data_selection}_loop_{i+1}"
    fasta_sequence = '\n'.join([current_seq[j:j+60] for j in range(0, len(current_seq), 60)])
    fasta_content = f"{fasta_header}\n{fasta_sequence}\n"

    fasta_path = f"/content/drive/MyDrive/Machine_Learning_FP_Evolution/{template_name}_{var.title()}_Reverse_Evolved_Sequences_From_ML.fasta"
    with open(fasta_path, 'a') as f:
        f.write(fasta_content)

    print(f"Appended evolved sequence to: {fasta_path}")
    print(f'\033[93mCompleted loop {i+1}/30\033[0m\n')

"""#PREDICT PROPERTIES FROM EVOLVED SEQUENCES"""

import re

mutations_applied = ['V21A', 'S26T', 'L66M', 'L129M', 'K167R', 'T179D', 'P191S']

# Your existing functions
max_len = 238
aa_alphabet = 'ACDEFGHIKLMNPQRSTVWY'
aa_index = {aa: i for i, aa in enumerate(aa_alphabet)}

def one_hot_encode(seq, max_len):
    arr = np.zeros((max_len, len(aa_alphabet)), dtype=np.float32)
    for i, aa in enumerate(seq[:max_len]):
        if aa in aa_index:
            arr[i, aa_index[aa]] = 1.0
    return arr.flatten()

def parse_mutation(mutation_str):
    match = re.match(r"([A-Z])(\d+)([A-Z])", mutation_str)
    if not match:
        raise ValueError(f"Invalid mutation format: {mutation_str}")
    orig_aa, pos, new_aa = match.groups()
    return int(pos), new_aa

def apply_mutations(seq, mutations):
    seq_list = list(seq)
    for pos, new_aa in mutations:
        if 1 <= pos <= len(seq_list):
            seq_list[pos - 1] = new_aa
        else:
            print(f"Warning: position {pos} is out of range.")
    return ''.join(seq_list)

# MAIN LOOP
vars = ['ex_max', 'em_max', 'stokes_shift', 'brightness']
n_runs = 10

for var in vars:
    template_seq = template
    parsed_mutations = [parse_mutation(m) for m in mutations_applied]

    template_preds = []
    mutant_preds = []

    for i in range(n_runs):
        # Load dataset
        seqs, vals = [], []
        for entry in proteins:
            seq = entry.get("seq")
            states = entry.get("states", [])
            val = None
            if states and isinstance(states, list):
                val = states[0].get(var)
            if seq and val is not None:
                seqs.append(seq)
                vals.append(val)


        X = np.array([one_hot_encode(seq, max_len) for seq in seqs])
        y = np.array(vals)

        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

        model = RandomForestRegressor(n_estimators=100)
        model.fit(X_train, y_train)

        # Evaluate
        mae = mean_absolute_error(y_test, model.predict(X_test))
        r2 = r2_score(y_test, model.predict(X_test))
        print(f"Run {i+1} {var}: MAE = {mae:.2f}, RÂ² = {r2:.2f}")

        # Predict template + mutant
        template_encoded = one_hot_encode(template_seq, max_len).reshape(1, -1)
        mutant_seq = apply_mutations(template_seq, parsed_mutations)
        mutant_encoded = one_hot_encode(mutant_seq, max_len).reshape(1, -1)

        template_pred = model.predict(template_encoded)[0]
        mutant_pred = model.predict(mutant_encoded)[0]

        template_preds.append(template_pred)
        mutant_preds.append(mutant_pred)

    # Plot
    labels = ['Template', 'Mutated']
    means = [np.mean(template_preds), np.mean(mutant_preds)]
    all_preds = [template_preds, mutant_preds]

    plt.figure(figsize=(5, 5))
    bars = plt.bar(labels, means, color=['gray', 'skyblue'], edgecolor='black')

    # Annotate mean
    for bar in bars:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width() / 2, height *1.03,
                 f"{height:.2f}", ha='center', va='bottom', zorder = 4)

    # Overlay individual run points
    for i, preds in enumerate(all_preds):
        x = np.full(len(preds), i) + np.random.uniform(-0.1, 0.1, size=len(preds))  # jitter
        plt.scatter(x, preds, color='k', zorder=3, edgecolor = 'k', s=4)

    plt.ylabel(f'Predicted {var.title()}')
    plt.title(f'Predicted {var.title()} Across {n_runs} Runs for Evolved {template_name}')
    plt.ylim(0, max(means + [max(p) for p in all_preds]) * 1.2)
    plt.axhline(0, color='k', linewidth=2)
    for spine in plt.gca().spines.values():
        spine.set_visible(False)

    plt.tight_layout()
    plt.show()
    print(f"Total usable sequences: {len(seqs)}")
    print(f'Applied Mutations: {mutations_applied}')